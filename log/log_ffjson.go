// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: log.go

package log

import (
	"bytes"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *Event) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Event) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"n":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteString(`,"ts":`)
	fflib.FormatBits2(buf, uint64(j.Timestamp), 10, j.Timestamp < 0)
	buf.WriteString(`,"uid":`)
	fflib.WriteJsonString(buf, string(j.UID))
	buf.WriteString(`,"fc":`)
	fflib.FormatBits2(buf, uint64(j.Fc), 10, j.Fc < 0)
	buf.WriteString(`,"dr":`)
	fflib.FormatBits2(buf, uint64(j.Dr), 10, j.Dr < 0)
	buf.WriteString(`,"vs":`)
	fflib.WriteJsonString(buf, string(j.Vs))
	buf.WriteString(`,"m":`)
	fflib.WriteJsonString(buf, string(j.M))
	buf.WriteString(`,"tc":`)
	fflib.FormatBits2(buf, uint64(j.Tc), 10, j.Tc < 0)
	buf.WriteString(`,"tg":`)
	fflib.WriteJsonString(buf, string(j.Tg))
	buf.WriteString(`,"sn":`)
	fflib.WriteJsonString(buf, string(j.Sn))
	buf.WriteString(`,"ps":`)
	fflib.WriteJsonString(buf, string(j.Ps))
	buf.WriteString(`,"ct":`)
	fflib.FormatBits2(buf, uint64(j.Ct), 10, j.Ct < 0)
	buf.WriteString(`,"lc":`)
	fflib.FormatBits2(buf, uint64(j.Lc), 10, j.Lc < 0)
	buf.WriteString(`,"sc":`)
	fflib.WriteJsonString(buf, string(j.Sc))
	buf.WriteString(`,"lf":`)
	fflib.FormatBits2(buf, uint64(j.Lf), 10, j.Lf < 0)
	buf.WriteString(`,"sp":`)
	fflib.WriteJsonString(buf, string(j.Sp))
	buf.WriteString(`,"st":`)
	fflib.WriteJsonString(buf, string(j.St))
	buf.WriteString(`,"Rid":`)
	fflib.WriteJsonString(buf, string(j.Rid))
	buf.WriteString(`,"res":`)
	fflib.FormatBits2(buf, uint64(j.Resolution), 10, j.Resolution < 0)
	buf.WriteString(`,"ori":`)
	fflib.WriteJsonString(buf, string(j.Ori))
	buf.WriteString(`,"ord":`)
	fflib.WriteJsonString(buf, string(j.Ord))
	buf.WriteString(`,"typ":`)
	fflib.FormatBits2(buf, uint64(j.Type), 10, j.Type < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEventbase = iota
	ffjtEventnosuchkey

	ffjtEventName

	ffjtEventTimestamp

	ffjtEventUID

	ffjtEventFc

	ffjtEventDr

	ffjtEventVs

	ffjtEventM

	ffjtEventTc

	ffjtEventTg

	ffjtEventSn

	ffjtEventPs

	ffjtEventCt

	ffjtEventLc

	ffjtEventSc

	ffjtEventLf

	ffjtEventSp

	ffjtEventSt

	ffjtEventRid

	ffjtEventResolution

	ffjtEventOri

	ffjtEventOrd

	ffjtEventType
)

var ffjKeyEventName = []byte("n")

var ffjKeyEventTimestamp = []byte("ts")

var ffjKeyEventUID = []byte("uid")

var ffjKeyEventFc = []byte("fc")

var ffjKeyEventDr = []byte("dr")

var ffjKeyEventVs = []byte("vs")

var ffjKeyEventM = []byte("m")

var ffjKeyEventTc = []byte("tc")

var ffjKeyEventTg = []byte("tg")

var ffjKeyEventSn = []byte("sn")

var ffjKeyEventPs = []byte("ps")

var ffjKeyEventCt = []byte("ct")

var ffjKeyEventLc = []byte("lc")

var ffjKeyEventSc = []byte("sc")

var ffjKeyEventLf = []byte("lf")

var ffjKeyEventSp = []byte("sp")

var ffjKeyEventSt = []byte("st")

var ffjKeyEventRid = []byte("Rid")

var ffjKeyEventResolution = []byte("res")

var ffjKeyEventOri = []byte("ori")

var ffjKeyEventOrd = []byte("ord")

var ffjKeyEventType = []byte("typ")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Event) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Event) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'R':

					if bytes.Equal(ffjKeyEventRid, kn) {
						currentKey = ffjtEventRid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyEventCt, kn) {
						currentKey = ffjtEventCt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyEventDr, kn) {
						currentKey = ffjtEventDr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyEventFc, kn) {
						currentKey = ffjtEventFc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyEventLc, kn) {
						currentKey = ffjtEventLc
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventLf, kn) {
						currentKey = ffjtEventLf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyEventM, kn) {
						currentKey = ffjtEventM
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyEventName, kn) {
						currentKey = ffjtEventName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyEventOri, kn) {
						currentKey = ffjtEventOri
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventOrd, kn) {
						currentKey = ffjtEventOrd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyEventPs, kn) {
						currentKey = ffjtEventPs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyEventResolution, kn) {
						currentKey = ffjtEventResolution
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyEventSn, kn) {
						currentKey = ffjtEventSn
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventSc, kn) {
						currentKey = ffjtEventSc
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventSp, kn) {
						currentKey = ffjtEventSp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventSt, kn) {
						currentKey = ffjtEventSt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyEventTimestamp, kn) {
						currentKey = ffjtEventTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventTc, kn) {
						currentKey = ffjtEventTc
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventTg, kn) {
						currentKey = ffjtEventTg
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventType, kn) {
						currentKey = ffjtEventType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyEventUID, kn) {
						currentKey = ffjtEventUID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyEventVs, kn) {
						currentKey = ffjtEventVs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventType, kn) {
					currentKey = ffjtEventType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventOrd, kn) {
					currentKey = ffjtEventOrd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventOri, kn) {
					currentKey = ffjtEventOri
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventResolution, kn) {
					currentKey = ffjtEventResolution
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventRid, kn) {
					currentKey = ffjtEventRid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventSt, kn) {
					currentKey = ffjtEventSt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventSp, kn) {
					currentKey = ffjtEventSp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventLf, kn) {
					currentKey = ffjtEventLf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventSc, kn) {
					currentKey = ffjtEventSc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventLc, kn) {
					currentKey = ffjtEventLc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventCt, kn) {
					currentKey = ffjtEventCt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventPs, kn) {
					currentKey = ffjtEventPs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventSn, kn) {
					currentKey = ffjtEventSn
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventTg, kn) {
					currentKey = ffjtEventTg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventTc, kn) {
					currentKey = ffjtEventTc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventM, kn) {
					currentKey = ffjtEventM
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventVs, kn) {
					currentKey = ffjtEventVs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventDr, kn) {
					currentKey = ffjtEventDr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventFc, kn) {
					currentKey = ffjtEventFc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventUID, kn) {
					currentKey = ffjtEventUID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventTimestamp, kn) {
					currentKey = ffjtEventTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventName, kn) {
					currentKey = ffjtEventName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEventName:
					goto handle_Name

				case ffjtEventTimestamp:
					goto handle_Timestamp

				case ffjtEventUID:
					goto handle_UID

				case ffjtEventFc:
					goto handle_Fc

				case ffjtEventDr:
					goto handle_Dr

				case ffjtEventVs:
					goto handle_Vs

				case ffjtEventM:
					goto handle_M

				case ffjtEventTc:
					goto handle_Tc

				case ffjtEventTg:
					goto handle_Tg

				case ffjtEventSn:
					goto handle_Sn

				case ffjtEventPs:
					goto handle_Ps

				case ffjtEventCt:
					goto handle_Ct

				case ffjtEventLc:
					goto handle_Lc

				case ffjtEventSc:
					goto handle_Sc

				case ffjtEventLf:
					goto handle_Lf

				case ffjtEventSp:
					goto handle_Sp

				case ffjtEventSt:
					goto handle_St

				case ffjtEventRid:
					goto handle_Rid

				case ffjtEventResolution:
					goto handle_Resolution

				case ffjtEventOri:
					goto handle_Ori

				case ffjtEventOrd:
					goto handle_Ord

				case ffjtEventType:
					goto handle_Type

				case ffjtEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: j.Timestamp type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Timestamp = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UID:

	/* handler: j.UID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fc:

	/* handler: j.Fc type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Fc = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dr:

	/* handler: j.Dr type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Dr = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Vs:

	/* handler: j.Vs type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Vs = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M:

	/* handler: j.M type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.M = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tc:

	/* handler: j.Tc type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Tc = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tg:

	/* handler: j.Tg type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tg = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sn:

	/* handler: j.Sn type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Sn = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ps:

	/* handler: j.Ps type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Ps = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ct:

	/* handler: j.Ct type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Ct = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lc:

	/* handler: j.Lc type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Lc = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sc:

	/* handler: j.Sc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Sc = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lf:

	/* handler: j.Lf type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Lf = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sp:

	/* handler: j.Sp type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Sp = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_St:

	/* handler: j.St type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.St = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rid:

	/* handler: j.Rid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Rid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resolution:

	/* handler: j.Resolution type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Resolution = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ori:

	/* handler: j.Ori type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Ori = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ord:

	/* handler: j.Ord type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Ord = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Type = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Log) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Log) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"REQUEST_TIME_FLOAT":`)
	fflib.AppendFloat(buf, float64(j.ReqTime), 'g', -1, 64)
	buf.WriteString(`,"REQUEST_URI":`)
	fflib.WriteJsonString(buf, string(j.ReqURI))
	buf.WriteString(`,"REMOTE_ADDR":`)
	fflib.WriteJsonString(buf, string(j.RemoteAddr))
	buf.WriteString(`,"CLIENT_ID":`)
	fflib.WriteJsonString(buf, string(j.ClientID))
	buf.WriteString(`,"HTTP_USER_AGENT":`)
	fflib.WriteJsonString(buf, string(j.HTTPUserAgent))
	if j.Event != nil {
		buf.WriteString(`,"event":`)

		{

			err = j.Event.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"event":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLogbase = iota
	ffjtLognosuchkey

	ffjtLogReqTime

	ffjtLogReqURI

	ffjtLogRemoteAddr

	ffjtLogClientID

	ffjtLogHTTPUserAgent

	ffjtLogEvent
)

var ffjKeyLogReqTime = []byte("REQUEST_TIME_FLOAT")

var ffjKeyLogReqURI = []byte("REQUEST_URI")

var ffjKeyLogRemoteAddr = []byte("REMOTE_ADDR")

var ffjKeyLogClientID = []byte("CLIENT_ID")

var ffjKeyLogHTTPUserAgent = []byte("HTTP_USER_AGENT")

var ffjKeyLogEvent = []byte("event")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Log) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Log) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLogbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLognosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyLogClientID, kn) {
						currentKey = ffjtLogClientID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'H':

					if bytes.Equal(ffjKeyLogHTTPUserAgent, kn) {
						currentKey = ffjtLogHTTPUserAgent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffjKeyLogReqTime, kn) {
						currentKey = ffjtLogReqTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyLogReqURI, kn) {
						currentKey = ffjtLogReqURI
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyLogRemoteAddr, kn) {
						currentKey = ffjtLogRemoteAddr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyLogEvent, kn) {
						currentKey = ffjtLogEvent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyLogEvent, kn) {
					currentKey = ffjtLogEvent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyLogHTTPUserAgent, kn) {
					currentKey = ffjtLogHTTPUserAgent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyLogClientID, kn) {
					currentKey = ffjtLogClientID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyLogRemoteAddr, kn) {
					currentKey = ffjtLogRemoteAddr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyLogReqURI, kn) {
					currentKey = ffjtLogReqURI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyLogReqTime, kn) {
					currentKey = ffjtLogReqTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLognosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLogReqTime:
					goto handle_ReqTime

				case ffjtLogReqURI:
					goto handle_ReqURI

				case ffjtLogRemoteAddr:
					goto handle_RemoteAddr

				case ffjtLogClientID:
					goto handle_ClientID

				case ffjtLogHTTPUserAgent:
					goto handle_HTTPUserAgent

				case ffjtLogEvent:
					goto handle_Event

				case ffjtLognosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ReqTime:

	/* handler: j.ReqTime type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReqTime = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReqURI:

	/* handler: j.ReqURI type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ReqURI = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemoteAddr:

	/* handler: j.RemoteAddr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RemoteAddr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClientID:

	/* handler: j.ClientID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ClientID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HTTPUserAgent:

	/* handler: j.HTTPUserAgent type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.HTTPUserAgent = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Event:

	/* handler: j.Event type=log.Event kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Event = nil

		} else {

			if j.Event == nil {
				j.Event = new(Event)
			}

			err = j.Event.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
